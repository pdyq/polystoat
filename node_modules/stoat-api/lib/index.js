export * from "./types.js";
import { defaultBaseURL } from "./baseURL.js";
import { pathResolve, queryParams } from "./params.js";
import { JSONParse, JSONStringify } from 'json-with-bigint';
/**
 * Get the specific path name of any given path.
 * @param anyPath Any path
 * @returns Specific path
 */
export function getPathName(anyPath) {
    const segments = anyPath.split("/");
    const list = pathResolve[(segments.length - 1).toString()] || [];
    for (const entry of list) {
        let i = 1;
        let copy = [...segments];
        for (i; i < segments.length; i++) {
            if (Array.isArray(entry[i - 1])) {
                copy[i] = entry[i - 1];
                continue;
            }
            else if (entry[i - 1] !== segments[i])
                break;
        }
        if (i === segments.length)
            return copy.join("/");
    }
}
/**
 * API Client
 */
export class API {
    baseURL;
    authentication;
    headers;
    constructor({ baseURL, authentication, headers } = {}) {
        this.baseURL = baseURL || defaultBaseURL;
        this.authentication = authentication || {};
        this.headers = headers || {};
    }
    /**
     * Generate authentication options.
     */
    get auth() {
        if (this.authentication.rauth) {
            if (typeof this.authentication.rauth === "string") {
                return {
                    "X-Session-Token": this.authentication.rauth,
                };
            }
        }
        else if (this.authentication.revolt) {
            switch (typeof this.authentication.revolt) {
                case "string": {
                    return {
                        "X-Bot-Token": this.authentication.revolt,
                    };
                }
                case "object": {
                    return {
                        "X-Session-Token": this.authentication.revolt.token,
                    };
                }
            }
        }
        else if (this.authentication.headers) {
            return this.authentication.headers;
        }
        return {};
    }
    /**
     * Generate config to pass through to API.
     */
    get config() {
        return {
            baseURL: this.baseURL,
            headers: {
                ...this.auth,
                ...this.headers,
            },
        };
    }
    /**
     * Send any arbitrary request.
     * @param method HTTP Method
     * @param path Path
     * @param params Body or Query Parameters
     * @param config Request configuration
     * @returns Typed Response Data
     */
    async req(method, path, params, config) {
        let query = new URLSearchParams();
        let body = {};
        let named = getPathName(path);
        // If we are aware of this route, then match the parameters given.
        if (named && typeof params === "object") {
            const route = queryParams[named];
            const allowed_query = route[method];
            // Map each parameter to the correct object.
            for (const parameter of Object.keys(params)) {
                // omit undefined values
                if (typeof params[parameter] !== "undefined") {
                    if (allowed_query?.includes(parameter)) {
                        query.append(parameter, params[parameter]);
                    }
                    else {
                        body[parameter] = params[parameter];
                    }
                }
            }
        }
        const passbody = ["head", "get"].includes(method)
            ? undefined
            : JSONStringify(body);
        let fetchpath = `${path}?${query.toString()}`;
        if (fetchpath.startsWith("/")) {
            fetchpath = (config?.baseURL || this.baseURL) + fetchpath;
        }
        const fetchdata = await fetch(new URL(fetchpath).toString(), {
            method: method.toUpperCase(),
            headers: {
                ...(config?.headers || {}),
                ...(this.config.headers || {}),
            },
            body: passbody,
        });
        const respType = config?.responseType || "json";
        const data = fetchdata.status === 204
            ? null
            : await fetchdata[respType === 'json' ? 'text' : respType]();
        if (fetchdata.ok) {
            return respType === 'json' ? JSONParse(data) : data;
        }
        else {
            throw data;
        }
    }
    get(path, params, config) {
        // @ts-ignore-next-line
        return this.req("get", path, params, config);
    }
    patch(path, params, config) {
        // @ts-ignore-next-line
        return this.req("patch", path, params, config);
    }
    put(path, params, config) {
        // @ts-ignore-next-line
        return this.req("put", path, params, config);
    }
    delete(path, params, config) {
        // @ts-ignore-next-line
        return this.req("delete", path, params, config);
    }
    post(path, params, config) {
        // @ts-ignore-next-line
        return this.req("post", path, params, config);
    }
}
