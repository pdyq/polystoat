import { batch, createSignal } from "solid-js";
import { AsyncEventEmitter } from "@vladfrangu/async_event_emitter";
import { API } from "stoat-api";
import { AccountCollection } from "./collections/AccountCollection.js";
import { BotCollection } from "./collections/BotCollection.js";
import { ChannelCollection } from "./collections/ChannelCollection.js";
import { ChannelUnreadCollection } from "./collections/ChannelUnreadCollection.js";
import { ChannelWebhookCollection } from "./collections/ChannelWebhookCollection.js";
import { EmojiCollection } from "./collections/EmojiCollection.js";
import { MessageCollection } from "./collections/MessageCollection.js";
import { ServerCollection } from "./collections/ServerCollection.js";
import { ServerMemberCollection } from "./collections/ServerMemberCollection.js";
import { SessionCollection } from "./collections/SessionCollection.js";
import { UserCollection } from "./collections/UserCollection.js";
import { ConnectionState, EventClient, } from "./events/EventClient.js";
import { handleEvent } from "./events/v1.js";
import { RE_CHANNELS, RE_MENTIONS, RE_SPOILER } from "./lib/regex.js";
/**
 * Stoat.js Clients
 */
export class Client extends AsyncEventEmitter {
    account;
    bots;
    channels;
    channelUnreads;
    channelWebhooks;
    emojis;
    messages;
    servers;
    serverMembers;
    sessions;
    users;
    api;
    options;
    events;
    configuration;
    #session;
    user;
    ready;
    #setReady;
    connectionFailureCount;
    #setConnectionFailureCount;
    #reconnectTimeout;
    /**
     * Create Stoat.js Client
     */
    constructor(options, configuration) {
        super();
        this.options = {
            baseURL: "https://stoat.chat/api",
            partials: false,
            eagerFetching: true,
            syncUnreads: false,
            autoReconnect: true,
            messageRewrites: true,
            /**
             * Retry delay function
             * @param retryCount Count
             * @returns Delay in seconds
             */
            retryDelayFunction(retryCount) {
                return (Math.pow(2, retryCount) - 1) * (0.8 + Math.random() * 0.4);
            },
            /**
             * Check whether a channel is muted
             * @param channel Channel
             * @return Whether it is muted
             */
            channelIsMuted() {
                return false;
            },
            /**
             * Check whether a channel is exclusively muted (irrespective of server)
             * @param channel Channel
             * @return Whether it is exclusively muted
             * @default false
             */
            channelExclusiveMuted() {
                return false;
            },
            ...options,
        };
        this.configuration = configuration;
        this.api = new API({
            baseURL: this.options.baseURL,
        });
        const [ready, setReady] = createSignal(false);
        this.ready = ready;
        this.#setReady = setReady;
        const [connectionFailureCount, setConnectionFailureCount] = createSignal(0);
        this.connectionFailureCount = connectionFailureCount;
        this.#setConnectionFailureCount = setConnectionFailureCount;
        this.account = new AccountCollection(this);
        this.bots = new BotCollection(this);
        this.channels = new ChannelCollection(this);
        this.channelUnreads = new ChannelUnreadCollection(this);
        this.channelWebhooks = new ChannelWebhookCollection(this);
        this.emojis = new EmojiCollection(this);
        this.messages = new MessageCollection(this);
        this.servers = new ServerCollection(this);
        this.serverMembers = new ServerMemberCollection(this);
        this.sessions = new SessionCollection(this);
        this.users = new UserCollection(this);
        this.events = new EventClient(1, "json", this.options);
        this.events.on("error", (error) => this.emit("error", error));
        this.events.on("state", (state) => {
            switch (state) {
                case ConnectionState.Connected:
                    batch(() => {
                        this.servers.forEach((server) => server.resetSyncStatus());
                        this.#setConnectionFailureCount(0);
                        this.emit("connected");
                    });
                    break;
                case ConnectionState.Connecting:
                    this.emit("connecting");
                    break;
                case ConnectionState.Disconnected:
                    this.emit("disconnected");
                    if (this.options.autoReconnect) {
                        this.#reconnectTimeout = setTimeout(() => this.connect(), this.options.retryDelayFunction(this.connectionFailureCount()) *
                            1e3);
                        this.#setConnectionFailureCount((count) => count + 1);
                    }
                    break;
            }
        });
        this.events.on("event", (event) => handleEvent(this, event, this.#setReady));
    }
    /**
     * Current session id
     */
    get sessionId() {
        return typeof this.#session === "string" ? undefined : this.#session?._id;
    }
    /**
     * Get authentication header
     */
    get authenticationHeader() {
        return typeof this.#session === "string"
            ? ["X-Bot-Token", this.#session]
            : ["X-Session-Token", this.#session?.token];
    }
    /**
     * Connect to Revolt
     */
    connect() {
        clearTimeout(this.#reconnectTimeout);
        this.events.disconnect();
        this.#setReady(false);
        this.events.connect(this.configuration?.ws ?? "wss://stoat.chat/events", typeof this.#session === "string" ? this.#session : this.#session.token);
    }
    /**
     * Fetches the configuration of the server if it has not been already fetched.
     */
    async #fetchConfiguration() {
        if (!this.configuration) {
            this.configuration = await this.api.get("/");
        }
    }
    /**
     * Update API object to use authentication.
     */
    #updateHeaders() {
        this.api = new API({
            baseURL: this.options.baseURL,
            authentication: {
                revolt: this.#session,
            },
        });
    }
    /**
     * Log in with auth data, creating a new session in the process.
     * @param details Login data object
     * @returns An on-boarding function if on-boarding is required, undefined otherwise
     */
    async login(details) {
        await this.#fetchConfiguration();
        const data = await this.api.post("/auth/session/login", details);
        if (data.result === "Success") {
            this.#session = data;
            // TODO: return await this.connect();
        }
        else {
            throw "MFA not implemented!";
        }
    }
    /**
     * Use an existing session
     */
    useExistingSession(session) {
        this.#session = session;
        this.#updateHeaders();
    }
    /**
     * Log in as a bot
     * @param token Bot token
     */
    async loginBot(token) {
        await this.#fetchConfiguration();
        this.#session = token;
        this.#updateHeaders();
        this.connect();
    }
    /**
     * Prepare a markdown-based message to be displayed to the user as plain text.
     * @param source Source markdown text
     * @returns Modified plain text
     */
    markdownToText(source) {
        return source
            .replace(RE_MENTIONS, (sub, id) => {
            const user = this.users.get(id);
            if (user) {
                return `@${user.username}`;
            }
            return sub;
        })
            .replace(RE_CHANNELS, (sub, id) => {
            const channel = this.channels.get(id);
            if (channel) {
                return `#${channel.displayName}`;
            }
            return sub;
        })
            .replace(RE_SPOILER, "<spoiler>");
    }
    /**
     * Proxy a file through January.
     * @param url URL to proxy
     * @returns Proxied media URL
     */
    proxyFile(url) {
        if (this.configuration?.features.january.enabled) {
            return `${this.configuration.features.january.url}/proxy?url=${encodeURIComponent(url)}`;
        }
        else {
            return url;
        }
    }
    /**
     * Upload a file
     * @param tag Tag
     * @param file File
     * @param uploadUrl Media server upload route
     */
    async uploadFile(tag, file, uploadUrl) {
        const body = new FormData();
        body.append("file", file);
        const [key, value] = this.authenticationHeader;
        const data = await fetch(`${uploadUrl ?? this.configuration?.features.autumn.url}/${tag}`, {
            method: "POST",
            body,
            headers: {
                [key]: value,
            },
        }).then((res) => res.json());
        return data.id;
    }
}
